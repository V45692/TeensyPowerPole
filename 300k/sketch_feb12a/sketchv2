#include <ADC.h>

// 8-byte packet for 32-bit alignment and easy Python parsing
struct __attribute__((packed)) DataPacket {
  uint16_t s1;   // ADC0
  uint16_t s2;   // ADC0 (sequential)
  uint16_t s3;   // ADC1
  uint16_t sync; // Alignment word 0xABCD
};

// --- Buffer Configuration ---
const int BUFFER_SIZE = 2000; 
DataPacket buffer0[BUFFER_SIZE];
DataPacket buffer1[BUFFER_SIZE];

ADC *adc = new ADC();
IntervalTimer timer;

volatile int bufIndex = 0;
volatile bool activeBuffer = 0; 
volatile bool bufferReady = false; 
volatile bool capturing = false;
volatile uint32_t totalSamples = 0;
const uint32_t LIMIT = 600000;

void captureISR() {
  if (!capturing) return;

  // 1. Parallel Start: S1 (ADC0) and S3 (ADC1) 
  adc->adc0->startSingleRead(A9);
  adc->adc1->startSingleRead(A2);

  // 2. Wait for parallel conversions (~1us)
  while(adc->adc0->isConverting() || adc->adc1->isConverting());

  DataPacket* currentBuf = (activeBuffer == 0) ? buffer0 : buffer1;

  // Store first two results
  currentBuf[bufIndex].s1 = (uint16_t)adc->adc0->readSingle();
  currentBuf[bufIndex].s3 = (uint16_t)adc->adc1->readSingle();
  currentBuf[bufIndex].sync = 0xABCD;

  // 3. Immediately start S2 on ADC0 (Sequential)
  currentBuf[bufIndex].s2 = (uint16_t)adc->adc0->analogRead(A8);
  
  bufIndex++;
  totalSamples++;

  // Check if we reached 600k
  if (totalSamples >= LIMIT) {
    timer.end();
    capturing = false;
    bufferReady = true; 
  } 
  // Swap buffers if full
  else if (bufIndex >= BUFFER_SIZE) {
    bufIndex = 0;
    activeBuffer = !activeBuffer;
    bufferReady = true; 
  }
}

void setup() {
  Serial.begin(115200); 
  pinMode(2, INPUT_PULLUP); 

  // --- ADC Setup ---
  adc->adc0->setAveraging(0);
  adc->adc0->setResolution(10);
  adc->adc0->setConversionSpeed(ADC_CONVERSION_SPEED::VERY_HIGH_SPEED);
  adc->adc0->setSamplingSpeed(ADC_SAMPLING_SPEED::VERY_HIGH_SPEED);

  adc->adc1->setAveraging(0);
  adc->adc1->setResolution(10);
  adc->adc1->setConversionSpeed(ADC_CONVERSION_SPEED::VERY_HIGH_SPEED);
  adc->adc1->setSamplingSpeed(ADC_SAMPLING_SPEED::VERY_HIGH_SPEED);

  Serial.println("System Ready. Pull Pin 2 to GND.");
}

void loop() {
  if (digitalRead(2) == LOW && !capturing) {
    delay(100); 
    totalSamples = 0;
    bufIndex = 0;
    capturing = true;
    Serial.println("START");
    timer.begin(captureISR, 3.3333); // 300,003 Hz
  }

  if (bufferReady) {
    bufferReady = false;
    void* dataToSend = (activeBuffer == 1) ? buffer0 : buffer1;
    Serial.write((uint8_t*)dataToSend, BUFFER_SIZE * sizeof(DataPacket));
    
    if (!capturing && totalSamples >= LIMIT) {
        Serial.println("DONE");
    }
  }
}
