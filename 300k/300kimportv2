import serial
import numpy as np

# --- CONFIGURATION ---
PORT = 'COM5'  # <--- DOUBLE CHECK THIS in Arduino IDE (Tools > Port)
FILENAME = "pole_test_data.npy"
PACKET_SIZE = 8  # Our struct: s1(2), s2(2), s3(2), padding(2)
SAMPLE_RATE = 300000 
DURATION = 2     # Seconds to record
TOTAL_SAMPLES = SAMPLE_RATE * DURATION

def run_collector():
    try:
        ser = serial.Serial(PORT, 2000000, timeout=2) # Higher timeout for safety
        ser.set_buffer_size(rx_size=20_000_000)
        print(f"Waiting for START on {PORT}...")

        while True:
            line = ser.readline().decode(errors='ignore').strip()
            if "START" in line:
                # IMPORTANT: Clear any lingering text or partial packets
                ser.reset_input_buffer() 
                print(">>> START Signal Received! Recording...")
                break
        
        # Read the blob
        bytes_to_read = TOTAL_SAMPLES * PACKET_SIZE
        # Use a loop or a large read to ensure we get exactly what we need
        raw_data = ser.read(bytes_to_read)
        
        print(f"Captured {len(raw_data)} bytes.")

        # Convert using Little-Endian explicitly
        num_complete_packets = len(raw_data) // PACKET_SIZE
        trimmed_data = raw_data[:num_complete_packets * PACKET_SIZE]
        
        # Interpret as Little-Endian uint16 (Teensy native)
        data = np.frombuffer(trimmed_data, dtype='<u2').reshape(-1, 4)
        
        # s1=col 0, s2=col 1, s3=col 2
        clean_data = data[:, :3]
        
        np.save(FILENAME, clean_data)
        print(f"Saved {num_complete_packets} samples. Shape: {clean_data.shape}")

    except Exception as e:
        print(f"ERROR: {e}")
    finally:
        ser.close()
