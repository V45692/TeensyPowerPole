import serial
import numpy as np
import time

PORT = 'COM5'  
FILENAME = "pole_test_data.npy"
PACKET_SIZE = 8       
SYNC_WORD = 0xABCD    
TOTAL_SAMPLES = 600000

def run_collector():
    try:
        ser = serial.Serial(PORT, 2000000, timeout=5)
        ser.set_buffer_size(rx_size=20_000_000)
        print(f"Waiting for START on {PORT}...")

        while True:
            line = ser.readline().decode(errors='ignore').strip()
            if "START" in line:
                print(">>> Recording 600,000 samples...")
                break
        
        # Calculate bytes to read
        expected_bytes = TOTAL_SAMPLES * PACKET_SIZE
        raw_data = b''
        
        # Read until we have the full dataset
        while len(raw_data) < expected_bytes:
            chunk = ser.read(expected_bytes - len(raw_data))
            if not chunk: break
            raw_data += chunk
            print(f"Progress: {len(raw_data)/expected_bytes:.1%}", end='\r')

        # Process data
        data_all = np.frombuffer(raw_data, dtype='<u2')
        
        # Alignment Sync logic
        offset = 0
        for i in range(4):
            if i < len(data_all) and data_all[i] == SYNC_WORD:
                # Sync word is the 4th element (index 3)
                offset = (i - 3) % 4
                break
        
        aligned_data = data_all[offset:]
        num_packets = len(aligned_data) // 4
        matrix = aligned_data[:num_packets * 4].reshape(-1, 4)

        # Final cleanup and save
        clean_data = matrix[:TOTAL_SAMPLES, :3]
        np.save(FILENAME, clean_data)
        print(f"\nSaved {len(clean_data)} samples to {FILENAME}")

    except Exception as e:
        print(f"\nERROR: {e}")
    finally:
        ser.close()

if __name__ == "__main__":
    run_collector()
